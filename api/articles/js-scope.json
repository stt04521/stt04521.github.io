{"title":"javascript 作用域 作用域链 垃圾回收 闭包","slug":"js-scope","date":"2017-07-10T14:13:05.000Z","updated":"2017-07-12T14:15:19.000Z","comments":true,"excerpt":"<p>对javascript 的 基础概念 进行解读</p>","content":"<p>对javascript 的 基础概念 进行解读</p>\n<a id=\"more\"></a>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>回顾基础，总结巩固，是一件非常重要的事，故此整理此篇文章。对js中比较基础但是又经常会遇见的知识点进行总结。</p>\n<h3 id=\"作用域及执行环境\"><a href=\"#作用域及执行环境\" class=\"headerlink\" title=\"作用域及执行环境\"></a>作用域及执行环境</h3><p>说起作用域用执行环境这个概念对比来理解的更为直观，作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的。执行环境始终是this关键字的值，它是拥有当前所执行代码的对象的引用。</p>\n<h4 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h4><p>作用域是你的代码在运行时，各个变量、函数和对象的可访问性。换句话说，作用域决定了你的代码里的变量和其他资源在各个区域中的可见性。</p>\n<h3 id=\"Javascript中的作用域\"><a href=\"#Javascript中的作用域\" class=\"headerlink\" title=\"Javascript中的作用域\"></a>Javascript中的作用域</h3><p>javascript中有两种作用域</p>\n<ul>\n<li>全局作用域</li>\n<li>局部作用域</li>\n</ul>\n<p>当变量定义在一个函数中时，变量就在局部作用域中，而定义在函数之外的变量则从属于全局作用域。每个函数在调用的时候会创建一个新的作用域。</p>\n<p>###全局作用域<br>当你在文档中（document）编写 JavaScript 时，你就已经在全局作用域中了。JavaScript 文档中（document）只有一个全局作用域。定义在函数之外的变量会被保存在全局作用域中。</p>\n<pre><code>var stt = &quot;Hello&quot;\n</code></pre><p>全局作用域里的变量能够在其他作用域中被访问和修改。</p>\n<pre><code>var stt = &quot;Hello&quot;\n\nconsole.log(stt);\n\nfunction logName() {\n    stt = &quot;olleh&quot;\n    console.log(name);\n};\n\nlogName() //&quot;olleh&quot;\n</code></pre><h3 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a>局部作用域</h3><p>定义在函数中的变量就在局部作用域中。并且函数在每次调用时都有一个不同的作用域。这意味着同名变量可以用在不同的函数中。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。</p>\n<pre><code>function logName() {\n    var stt = &quot;olleh&quot;\n};\n\nconsole.log(stt);\n//stt is not defined\n</code></pre><h3 id=\"块语句\"><a href=\"#块语句\" class=\"headerlink\" title=\"块语句\"></a>块语句</h3><p>块级声明包括if和switch，以及for和while循环，和函数不同，它们不会创建新的作用域。在块级声明中定义的变量从属于该块所在的作用域。</p>\n<pre><code>if(true){\n    var stt = &quot;Hello&quot;\n}\n\nconsole.log(stt)//&quot;Hello&quot;\n</code></pre><p>es6中let和const关键字支持在块级声明中创建使用局部作用域。</p>\n<pre><code>if(true){\n    let stt = &quot;Hello&quot;;\n    const likes = &quot;Coding&quot;;\n}\n\nconsole.log(stt)//stt is not defined\nconsole.log(likes)//likes is not defined\n</code></pre><h3 id=\"上下文\"><a href=\"#上下文\" class=\"headerlink\" title=\"上下文\"></a>上下文</h3><p>很多开发者经常弄混作用域和上下文，似乎两者是一个概念。但并非如此。作用域是我们上面讲到的那些，而上下文通常涉及到你代码某些特殊部分中的this值。作用域指的是变量的可见性，而上下文指的是在相同的作用域中的this的值。我们当然也可以使用函数方法改变上下文，这个之后我们再讨论。在全局作用域中，上下文总是 Window 对象。</p>\n<h3 id=\"执行环境（execution-context）\"><a href=\"#执行环境（execution-context）\" class=\"headerlink\" title=\"执行环境（execution context）\"></a>执行环境（execution context）</h3><p>JavaScript是一个单线程语言，意味着同一时间只能执行一个任务。当JavaScript解释器初始化执行代码时，<br>它首先默认进入全局执行环境（execution context），从此刻开始，函数的每次调用都会创建一个新的执行环境。</p>\n<p>这里会经常引起新手的困惑，这里提到了一个新的术语——执行环境（execution context），它定义了变量或函数有权访问的其他数据，决定了它们各自的行为。<br>它更偏向于作用域的作用，而不是我们前面讨论的上下文（Context）。请务必仔细的区分执行环境和上下文这两个概念（注：英文容易造成混淆）。</p>\n<p>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中（execution stack）。在函数执行完后，栈将其环境弹出，<br>把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个便利的机制控制着。</p>\n<p>执行环境可以分为创建和执行两个阶段。在创建阶段，解析器首先会创建一个变量对象（variable object，也称为活动对象 activation object），<br>它由定义在执行环境中的变量、函数声明、和参数组成。在这个阶段，作用域链会被初始化，this的值也会被最终确定。<br>在执行阶段，代码被解释执行。</p>\n<p>每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。<br>需要知道，我们无法手动访问这个对象，只有解析器才能访问它。</p>\n<h3 id=\"作用域链（The-Scope-Chain）\"><a href=\"#作用域链（The-Scope-Chain）\" class=\"headerlink\" title=\"作用域链（The Scope Chain）\"></a>作用域链（The Scope Chain）</h3><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。<br>作用域链包含了在环境栈中的每个执行环境对应的变量对象。通过作用域链，可以决定变量的访问和标识符的解析。<br>注意，全局执行环境的变量对象始终都是作用域链的最后一个对象。我们来看一个例子：</p>\n<pre><code>var color = &quot;blue&quot;;\n function changeColor(){\n var anotherColor = &quot;red&quot;;\n\n function swapColors(){\n    var tempColor = anotherColor;\n    anotherColor = color;\n    color = tempColor;\n\n    // 这里可以访问color, anotherColor, 和 tempColor\n  }\n\n  // 这里可以访问color 和 anotherColor，但是不能访问 tempColor\n  swapColors();\n}\n\nchangeColor();\n\n// 这里只能访问color\nconsole.log(&quot;Color is now &quot; + color);\n</code></pre><p>对于标识符解析（变量名或函数名搜索）是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，<br>然后逐级地向后（全局执行环境）回溯，直到找到标识符为止。</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>闭包是指有权访问另一函数作用域中的变量的函数。换句话说，在函数内定义一个嵌套的函数时，就构成了一个闭包，<br>它允许嵌套函数访问外层函数的变量。通过返回嵌套函数，允许你维护对外部函数中局部变量、参数、和内函数声明的访问。<br>这种封装允许你在外部作用域中隐藏和保护执行环境，并且暴露公共接口，进而通过公共接口执行进一步的操作。可以看个简单的例子：</p>\n<pre><code>function foo(){\n    var localVariable = &apos;private variable&apos;;\n    return function bar(){\n        return localVariable;\n    }\n}\n\nvar getLocalVariable = foo();\ngetLocalVariable() // private variable\n</code></pre><p>闭包有三个特性：</p>\n<ul>\n<li>函数嵌套函数</li>\n<li>函数内部可以引用外部的参数和变量</li>\n<li>参数和变量不会被垃圾回收机制回收</li>\n</ul>\n<p>那么使用闭包有什么好处呢？使用闭包的好处是：</p>\n<ul>\n<li>希望一个变量长期驻扎在内存中</li>\n<li>避免全局变量的污染</li>\n<li>私有成员的存在</li>\n</ul>\n<p>模块模式最流行的闭包类型之一，它允许你模拟公共的、私有的、和特权成员：</p>\n<pre><code> var Module = (function(){\nvar privateProperty = &apos;foo&apos;;\n\nfunction privateMethod(args){\n    // do something\n}\n\nreturn {\n\n    publicProperty: &apos;&apos;,\n\n    publicMethod: function(args){\n        // do something\n    },\n\n    privilegedMethod: function(args){\n        return privateMethod(args);\n    }\n};\n})();\n</code></pre><h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>在你学习高级的设计模式之前，理解这些概念非常的重要，因为作用域和上下文在现代JavaScript中扮演着的最基本的角色。<br>无论我们谈论的是闭包、面向对象、继承、或者是各种原生实现，上下文和作用域都在其中扮演着至关重要的角色。<br>如果你的目标是精通JavaScript语言，并且深入的理解它的各个组成，那么作用域和上下文便是你的起点。</p>\n","thumbnail":"https://i.pximg.net/c/600x600/img-master/img/2017/07/06/00/30/55/63724173_p0_master1200.jpg","categories":[{"name":"技术","path":"api/categories/技术.json"}],"tags":[{"name":"javascript","path":"api/tags/javascript.json"}]}