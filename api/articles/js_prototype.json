{"title":"javascript  原型 原型链","slug":"js_prototype","date":"2017-07-08T05:25:55.000Z","updated":"2017-07-09T01:48:00.000Z","comments":true,"excerpt":"<p>深入理解 javascript 底层 原型概念<br>","content":"<p>深入理解 javascript 底层 原型概念<br><a id=\"more\"></a></p>\n<h5 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h5><p>原型是  javascript 中比较难理解的概念，原型相关的属性也比较多。面试过很多前端，但是对这些概念还是难以说清。故整理这篇文章，希望通过这篇文章能清楚的认识到原型。</p>\n<h5 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h5><p>我们创建的每一个函数都有一个 prototype (原型)属性，这个属性是一个指针，指向一个对象。这个对象就是我们所说的原型对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。通俗点讲原型对象就是内存中为其他对象提供共享属性和方法的对象，可以理解为 prototype 就是通过调用构造函数创建的对象实例的原型对象。</p>\n<p>简单的讲解一下调用构造函数创建的对象实例 new 的过程：</p>\n<pre><code> function Gf(){\n\n     };\n   Gf.prototype.name = name;\n     Gf.prototype.bar = bar;\n     Gf.prototype.sayWhat = function() {\n      alert(this.name + &quot;said:love you forever&quot;);\n          }\n\n var gf1 = new Gf();\n\n //new的流程\n //var obj  = {};\n //obj.__proto__ = Gf.prototype;\n //Gf.call(obj);\n//1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。\n  //2、属性和方法被加入到 this 引用的对象中。\n //3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。\n //简单的说就是改变this指向，继承原型，返回新对象\n</code></pre><p>通过 new 的过程我们可以发现，obj 有一个隐性属性 [[prototype]] 指向它构造函数的原型对象(在firefox,safari,chrome浏览器中表现为私有属性proto)。一般默认情况下，所有原型对象都会自动获取一个 constructor 属性，这个属性指向 prototype 属性所在的函数。</p>\n<p>通过一个示意图弄清它们之间关系：</p>\n<p><img src=\"http://osrd7dt4l.bkt.clouddn.com/17-7-9/36128636.jpg\" alt=\"\"></p>\n<p>构造函数Gf有一个prototype属性，指向一个原型对象。这个原型对象上包含，通过Gf创建出来的对象实例之间能共享的方法和属性，包含一个constructor属性指向Gf，gf1和gf2都含有一个内部属性指向原型对象</p>\n<h5 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h5><p>原型链是实现继承的主要方法</p>\n<pre><code>function Foo(){};\nFoo.prototype.a = 100;\nFoo.prototype.b = 200;\n\nvar f1 = new Foo();\nf1.a = 10;\n\nconsole.log(f1.a) //10\nconsole.log(f1.b) //200\n</code></pre><p>以上代码中，f1是Foo函数new出来的对象，f1.a是f1对象的基本属性，f1.b是怎么来的呢？——从Foo.prototype得来，因为f1.<strong>proto</strong>指向的是Foo.prototype</p>\n<p>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<strong>proto</strong>这条链向上找，这就是原型链。</p>\n<p><img src=\"http://osrd7dt4l.bkt.clouddn.com/17-7-9/76790961.jpg\" alt=\"\"></p>\n<p>上图中，访问f1.b时，f1的基本属性中没有b，于是沿着<strong>proto</strong>找到了Foo.prototype.b。</p>\n<p>我们可以通过 hasOwnProperty 区分一个属性到底是基本的还是从原型中找到。hasOwnProperty方法是从哪里来的？</p>\n<p><img src=\"http://osrd7dt4l.bkt.clouddn.com/17-7-9/45235155.jpg\" alt=\"\"></p>\n<p>Foo.prototype 本质上也是一个对象，对象就会存在一个<strong>proto</strong>属性 ，会指向实例化它的构造函数(function Object(){})的prototype(Object.prototype).由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。</p>\n<h5 id=\"补充知识点\"><a href=\"#补充知识点\" class=\"headerlink\" title=\"补充知识点\"></a>补充知识点</h5><ul>\n<li>在原型上的方法跟属性，有所改动时，已经实例化出来的对象，能随着原型的改变而动态改变。在构造函数上的方法跟属性，已经实例化出来的对象，无法感知到变化。</li>\n</ul>\n","thumbnail":"https://i.pximg.net/c/600x600/img-master/img/2017/07/06/00/13/47/63723851_p0_master1200.jpg","categories":[{"name":"技术","path":"api/categories/技术.json"}],"tags":[{"name":"javascript","path":"api/tags/javascript.json"}]}